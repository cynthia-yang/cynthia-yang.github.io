<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>《认知与设计——理解UI设计准则》读书笔记 | 小圆子酱酱</title>
  <meta name="author" content="Cynthia Yang">
  
  <meta name="description" content="本书英文原名：Designing with the mind in mind: Simple guide to understanding user interface design rules.本书作者：Jeff Johnson，耶鲁大学和斯坦福大学心理学学位，UI Wizards公司董事长兼首席顾问，GUI先驱，著有《GUI设计禁忌》。本书的特点是将设计准则与其背后的认知心理学原理联系起来，帮助设计师理解设计原则的理论依据，从而加深对设计原则的理解，帮助设计师对设计原则进行更合适的应用。作者提出的设计原则：

专注于用户和他们的任务，而不是技术（了解用户；了解所执行的任务；考虑软件运行环境）
先考虑功能，再考虑展示（开发一个概念模型）
与用户看任务的角度一致（尽可能自然；使用用户所用的词汇而不是自己创造的；封装，不暴露程序的内部运作；找到功能与复杂度的平衡点）
为常见的情况而设计（保证常见的结果容易实现；两类常见：“很多人”与“很经常”；为核心情况而设计，不要纠结于边缘情况）
不要把用户的任务复杂化（不要给用户额外的问题；清除那些用户经过琢磨推导才会用的东西）
方便学习（“从外向内”而不是“从内向外”思考；一致，一致，还是一致；提供一个低风险的学习环境）
传递信息，而不是数据（仔细设计显示，争取专业的帮助；屏幕是用户的；保持显示的惯性）
为响应度而设计（即刻确认用户的操作；让用户知道软件是否在忙；在等待时允许用户做别的事情；动画要做到平滑和清晰；让用户能够终止长时间的操作；让用户能够预计操作所需的时间；尽可能让用户来掌控自己的工作节奏）
让用户试用后再修改（测试结果会让设计者感到惊讶；安排时间纠正测试发现的问题；测试有两个目的：信息目的和社会目的；每一个阶段和每一个目标都要测试）">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="《认知与设计——理解UI设计准则》读书笔记"/>
  <meta property="og:site_name" content="小圆子酱酱"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="小圆子酱酱" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">小圆子酱酱</a></h1>
  <h2><a href="/">～减肥中，禁止投喂～</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/about">About</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-01-12T08:19:33.000Z"><a href="/2015/01/12/Designing-with-the-mind-in-mind/">1月 12 2015</a></time>
      
      
  
    <h1 class="title">《认知与设计——理解UI设计准则》读书笔记</h1>
  

    </header>
    <div class="entry">
      
        <p>本书英文原名：Designing with the mind in mind: Simple guide to understanding user interface design rules.本书作者：Jeff Johnson，耶鲁大学和斯坦福大学心理学学位，UI Wizards公司董事长兼首席顾问，GUI先驱，著有《GUI设计禁忌》。<br>本书的特点是将设计准则与其背后的认知心理学原理联系起来，帮助设计师理解设计原则的理论依据，从而加深对设计原则的理解，帮助设计师对设计原则进行更合适的应用。<br><strong>作者提出的设计原则</strong>：</p>
<ol>
<li>专注于用户和他们的任务，而不是技术（了解用户；了解所执行的任务；考虑软件运行环境）</li>
<li>先考虑功能，再考虑展示（开发一个概念模型）</li>
<li>与用户看任务的角度一致（尽可能自然；使用用户所用的词汇而不是自己创造的；封装，不暴露程序的内部运作；找到功能与复杂度的平衡点）</li>
<li>为常见的情况而设计（保证常见的结果容易实现；两类常见：“很多人”与“很经常”；为核心情况而设计，不要纠结于边缘情况）</li>
<li>不要把用户的任务复杂化（不要给用户额外的问题；清除那些用户经过琢磨推导才会用的东西）</li>
<li>方便学习（“从外向内”而不是“从内向外”思考；一致，一致，还是一致；提供一个低风险的学习环境）</li>
<li>传递信息，而不是数据（仔细设计显示，争取专业的帮助；屏幕是用户的；保持显示的惯性）</li>
<li>为响应度而设计（即刻确认用户的操作；让用户知道软件是否在忙；在等待时允许用户做别的事情；动画要做到平滑和清晰；让用户能够终止长时间的操作；让用户能够预计操作所需的时间；尽可能让用户来掌控自己的工作节奏）</li>
<li>让用户试用后再修改（测试结果会让设计者感到惊讶；安排时间纠正测试发现的问题；测试有两个目的：信息目的和社会目的；每一个阶段和每一个目标都要测试）<a id="more"></a>

</li>
</ol>
<p><strong>——————正文分割线——————</strong></p>
<h3 id="第一章：我们感知自己的期望">第一章：我们感知自己的期望</h3>
<ul>
<li>经验影响预期<br>例：先入为主，二义图像。</li>
<li>环境影响预期<br>环境包括感知到的其他邻近对象和事件，甚至由环境激活的对以往感知到的对象和事件的记忆。</li>
<li>目标影响预期<br>与目标无关的东西会被提前过滤掉，不会进入到意识层面。目标影响感知的机理有二：第一，影响我们注意什么；第二，使我们的感知系统对某些特性敏感。<br><strong>对设计的启发：</strong></li>
<li>避免歧义信息<br>通过测试确认所有用户对信息的理解是一致的。</li>
<li>保持一致<br>不同页面上的相同功能的控件和数据显示应该摆放在每一页上相同的位置，并保持相同的颜色、字体和阴影等，这样的一致性能让用户很快找到并识别它们。</li>
<li>理解目标<br>设计者应理解用户目标，在一次交互的每个点上，确保提供了用户需要的信息，并非常清晰地对应到一个可能的用户目标。</li>
</ul>
<h3 id="第二章：为观察结构优化我们的视觉">第二章：为观察结构优化我们的视觉</h3>
<p><strong>视觉感知中的格式塔原理：</strong></p>
<ul>
<li>接近性<br>可以通过拉近某些对象之间的距离，拉开与其他对象的距离使它们在视觉上成为一组，而不需要分组框或者可见的边界——减少用户界面上的视觉凌乱    感和代码数量。</li>
<li>相似性<br>上述两个格式塔原理都与我们试图给对象分组的倾向相关，另外几个格式塔原理则与我们的视觉系统试图解析模糊或者填补遗漏来感知整个物体的倾向相关。</li>
<li>连续性<br>我们的视觉倾向于感知连续的形式而不是离散的碎片。例子：IBM的logo，由非连续的蓝色块组成，但一点也不含糊，很容易就能看到三个粗体字母。<img src="http://hello-world-hello.qiniudn.com/ibm_416x416.jpg" alt="IBM"> <strong>滑动条控件也是使用了连续性原理的一个例子</strong>。</li>
<li>封闭性<br>我们的视觉系统自动尝试将敞开的图形关闭起来，从而使其感知为完整的物体而不是分散的碎片。例，显示一个完整的对象和其背后对象的一角就足以让用户感知到由一叠对象构成的整体。</li>
<li>对称性<br>我们倾向于分解复杂的场景来降低复杂度。</li>
<li>主体/背景<br>在用户界面中，在主要显示内容之后放置印象诱导的背景。背景可以传递信息（用户当前所在位置），或者暗示一个主题、品牌或者内容所表达的情绪。  </li>
<li>共同命运<br>一起运动的物体被感知为属于一组或者是彼此相关的。</li>
</ul>
<h3 id="第三章：我们寻找和使用视觉结构">第三章：我们寻找和使用视觉结构</h3>
<p>当信息以简洁和结构化的方式呈现时，人们更容易浏览和理解。通过信息结构化和避免重复的“噪声”来提高用户浏览速度。例如，将长串数字用空格分割成几部分。<br>可视化信息显示的最重要目标之一是提供一个视觉层次，即信息的布置安排能够：</p>
<ul>
<li>将信息分段，把大块整段的信息分割为各个小段</li>
<li>显著标记每个信息段和子段，以便清晰确认各自的内容</li>
<li>以一个层次结构来展示各段及其子段，使上层的段能够比下层更重点的被展示</li>
</ul>
<h3 id="第四章：阅读不是自然的">第四章：阅读不是自然的</h3>
<p>阅读是一种人造的、通过系统指导和训练获得的能力。阅读是一种模式识别。<br>两种路径：自下而上、特征驱动的，和自上而下、语境驱动的。自下而上即从线条到字符到词语到句子；自上而下则是从句子到词语到字符，先知晓整体含义。<br><strong>最有效的阅读方式是无语境的、自下而上的特征驱动的方式。</strong>这需要熟练掌握到无意识的程度。语境驱动阅读在如今主要被视为一种候补的方法，只有在特征驱动阅读存在困难或者不能达到无意识的时候才起作用。<br>糟糕的书写或显示会将无意识的阅读降低为有意识的基于语境的阅读，增加记忆负担，降低阅读速度和理解能力。例如：使用过多术语，使用难以辨认的字型，字体过小，背景干扰等。<br>注意，<strong>视觉噪声也能来自文字本身。</strong>如果连续多行文字里有许多重复内容，读者接收到的相关反馈就太少，不知道自己正在读哪一行。这也让人很难从中提取出重要的信息。<br>软件里要求的阅读很多都是不必要的，要尽量少让人们阅读。</p>
<h3 id="第五章：色觉是有限的">第五章：色觉是有限的</h3>
<p>人类对色彩的视觉感知机制：颜色对抗通道。<br>人类视觉的特点：</p>
<ul>
<li>对对比度敏感，而不是绝对亮度。</li>
<li>区别颜色的能力取决于颜色是如何呈现的。三个影响因素：深浅度，色块的大小，分隔的距离。<br>（蓝色是人眼最不敏感的颜色，对其深浅辨识度最低。红&gt;绿&gt;蓝）</li>
<li>色盲用户：色盲并不意味着看不到颜色，而只是一个或者多个色彩减影通道无法正常工作，以致不能区分某些颜色对。应将图像转换为灰度图来了解哪些用色是色盲用户难以区分的。并在颜色之外使用其他提示信息。</li>
</ul>
<h3 id="第六章：我们的边界视力很糟糕">第六章：我们的边界视力很糟糕</h3>
<p><strong>中央凹</strong>：人类视野的分辨率从中央向边缘锐减。中央凹仅占视网膜面积的1%，而大脑的视觉皮层却有50%的区域用于接受中央凹的输入。边界视觉的信息在被传递到大脑之前是经压缩的（数据有损），而中央凹的视觉信息则不是。中央凹的分辨率大概是每英寸几千个点，而只要出了中央凹就下降到每英寸几百个点。<br><strong>那么，为什么我们看到的世界不是一个“隧道”？即除了直接注视的东西，其他所有东西都是失焦的？</strong></p>
<ul>
<li>答：我们之所以看周围的东西也是清晰的，是因为我们的眼睛以大约每秒三次的速度不断快速移动，选择性的将焦点投射在周围的环境物体上，大脑则用粗犷、印象派的方式，基于我们所知和所期待的，填充视野的其他部分。大脑无需为我们四周的环境保持一个高分辨率的心理模型，因为它能够命令眼睛在需要的时候去采样和重新采样具体细节。<br>我中央凹及其边缘的小块区域是能够阅读的部分，视野的其他部分不能用于阅读。</li>
</ul>
<p><strong>为什么要存在边界视觉？</strong></p>
<ul>
<li>答：边界视觉的存在主要是为了提供低分辨率的线索，以引导眼球运动，使得中央凹能够看到视野里所有有趣和重要的东西。我们的眼睛不是随机扫描环境的，眼动是为了使中央区关注重要的东西。我们视野周边的模糊线索提供了信息，帮助大脑计划往哪里以及什么顺序移动眼睛。<br>例如，我们在农产品市场里寻找草莓，一个在视觉边缘模糊的红色色块就能够吸引我们的眼球和注意力，虽然它有时只是块红色的东西而不是草莓。</li>
</ul>
<p>注意，<strong>如果我们没有期待视野边缘会出现什么有趣的东西，那我们的中央凹不会看到那里，我们永远也不会看到那里有什么。</strong>因此，设计交互界面时，一定要将交互（反馈）信息放在人们可预期的集中注意力的地方。</p>
<h3 id="第七章：我们的注意力有限，记忆力也不完美">第七章：我们的注意力有限，记忆力也不完美</h3>
<p><strong>短期记忆</strong>的特点：低容量、不稳定性（将注意转移到新事物上就得将其从之前关注的事物上移开）<br>对设计的启发：用户界面应帮助用户从一个时刻到下一个时刻记住核心的信息，不要要求用户记住系统状态或者他们已经做了什么，因为他们的注意力专注于主要目标和朝向目标的进度。</p>
<ul>
<li>模式<br>在一个使用模式的用户界面下，一些用户操作根据系统所在的模式而有不同的效果，如同样是按下快门的操作，可以是拍照也可以是录像，这取决于当前处于哪个模式。带有模式的用户界面有其优势：模式允许一个设备具有比控件还多的功能，同样的控件在不同模式下提供不同的功能。模式让交互系统分配不同的意义给同样的操作从而减少用户必须学习的操作的数量。<br>然而，模式最大的缺点，就是人们经常犯模式错误：用户会忘记系统当前所处的模式而导致误操作。——<strong>要么避免模式，要么提供清晰、连续的模式反馈。</strong></li>
<li>搜索结果<br>人们查看搜索结果时经常会忘记用的搜索词是什么。搜索结果一定要同时显示这个结果所用的搜索词。</li>
</ul>
<p><strong>长期记忆</strong>的特点：容易出错，需要不断巩固加强。<br>对设计的启发：用户界面的<strong>一致性</strong>有助于学习和长期记忆。<br>操作越一致，用户要学的就越少。存在例外或在功能与对象操作上具有很少一致性的用户界面，会要求用户在长期记忆里为每个功能、每个对象以及正确的使用环境存储许多特征。要求用户记忆太多特征会导致界面难以学习，也使得用户记忆更容易在回忆时丢失核心特征，增加用户无法记起、记错的可能性。<br>| 对象的剪切操作 | 设计A | 设计B | 设计C |<br>| —- | ———- | ———- | ———— |<br>| 文本 | CNTRL-X | CNTRL-X | CNTRL-X |<br>| 草图 | CNTRL-X | CNTRL-C | CNTRL-X |<br>| 表格 | CNTRL-X | CNTRL-Z | CNTRL-X |<br>| 图像 | CNTRL-X | CNTRL-M | CNTRL-X |<br>| 视频 | CNTRL-X | CNTRL-V | CNTRL-R |<br>如上图所示，三种设计方案分别为不同对象的剪切操作给出了三种设计方案，那么问题来了：哪一个最容易学？相当明显，设计A最容易。第二个问题：哪个最难学？这是个比较难的问题。设计B看起来似乎是最难的。但是这取决于“最难学”的定义是什么。<br>如果将难学定义为“最难上手”，那么肯定是设计B，然而，如果将其定义为<strong>“达到无错使用所需要的学习时间最长”</strong>，那么答案就是设计C。除了视频对象，其他对象的操作都一样，虽然用户很快就能上手，但他们至少在几个月里，甚至一直会持续错误使用CNTRL-X对视频对象进行操作。<strong>偶然的例外更加难以预测、难以回忆。要么保持绝对一致，要么保持绝对不同，没有规则的偶然例外是最难以记忆的。</strong></p>
<h3 id="第八章：对注意力、形状、思考以及行动的限制">第八章：对注意力、形状、思考以及行动的限制</h3>
<p><strong>六种人类行为模式：</strong></p>
<ol>
<li>我们专注于目标而很少注意使用的工具<br>当注意力转移到工具上，我们就无法顾及任务的细节了。这种注意力转移会让我们跟不上正在做的事情或者任务进度。例如，如果你在割草，只有割草机停止工作的时候你才会把注意力转移到割草机上，重新启动割草机成了你的任务。当割草机重新启动，你重新开始割草时，你多半忘记了你割到草地的什么地方了，但草地会提示你。<br>其他任务，比如阅读一个文档、数鱼缸里有多少条金鱼等，却未必能为被中断的任务提供一个如此清晰的提示，告诉你当前所处的进度。你可能不得不重新开始，你甚至可能完全忘记了自己刚才在做什么，而转身去做其他事情。<br><strong>软件不应唤起用户对软件本身的注意，它们应该隐入背景中。</strong></li>
<li>我们使用外部帮助来记录正在做的事情<br>交互系统应该识别出哪些是用户已经完成的，而哪些是用户还没完成的。<br>交互系统应该允许用户标记或者移动对象，以便分别标识出哪些是他们已经做过的，哪些是还没做过的。</li>
<li>我们跟着信息“气味”靠近目标<br>把注意力集中在目标上使得我们只从字面上理解在屏幕上看到的信息——“跟随信息的气味靠近目标”。人们只会注意到屏幕上与他们的目标匹配的东西。如果脑子里想的是预定航班，人们的注意力会被屏幕上任何带有“购买”、“航班”、“机票”或者“预定”的东西吸引。<br>设计者应理解用户每次在做决定时目标可能是什么，保证交互界面清晰标识出各个目标对应的选项（直接指示目标）。</li>
<li>我们偏好熟悉的路径<br><strong>我赶时间，所以我走了远路</strong>——这是因为不熟悉的近路可能会花费更多时间。<br>一旦我们学会了采用某种方法来执行某个任务，我们可能会继续这么做，不会再去找更有效的方法。甚至当被告知有“更好”的方法时，我们可能还是会用老方法，因为熟悉、舒适，最重要的是不需要动脑子。<br>有时不动脑子胜过按键。<strong>一般软件的使用频度没有高到让人在乎每个任务中所需的按键次数。</strong>因此，很快上手很重要，减少问题比减少按键要重要得多。但对于那些在紧张环境中或者全天使用软件的训练有素的用户，每个任务中的每一次的按键都在增加成本。<br>引导用户到最佳路径。在第一屏或者网站主页上，就应把到达用户目标的路径展现出来。<br>帮助有经验的用户提高效率。在用户获得经验后，应让他们能够很容易转移到更快的路径上。</li>
<li>我们的思考周期：目标-执行-评估<br>软件帮助用户完成这一周期的方式：<br>目标  提供完成目标的清晰路径；<br>执行  软件中的概念应该基于用户任务而不是基于如何实现。不要逼迫用户去搞清楚软件里的对象和动作是如何对应到要执行的任务的。在每个需要为实现目标做选择的节点上提供清晰的气味。<br>评估  向用户提供进度反馈和状态信息。能让用户离开那些不能帮助实现目标的操作。</li>
<li>完成任务的主要目标之后，我们经常忘记做收尾工作<br>注意力是稀缺资源，完成一个任务后注意力将被释放并转移到更重要的任务上。任务尾巴上短期记忆失效是完全可以预计到的：<ul>
<li>抵达目的地之后，忘记把汽车的前灯关掉</li>
<li>在公共场所使用电脑后忘记注销账号；</li>
<li>在特殊模式下使用设备或软件后忘记切换回普通状态……<br>如果有用户可能会忘记的扫尾工作，应该把系统设计成帮助用户记住，或者根本不需要用户记住。</li>
</ul>
</li>
</ol>
<h3 id="第九章_识别容易，回忆很难">第九章 识别容易，回忆很难</h3>
<p><strong>识别</strong>是感觉与长期记忆的协同工作：由感官来的感觉线索激活某种神经活动模式；<strong>回忆</strong>是在没有直接类似感觉输入时，长期记忆对神经模式的重新激活，这要比用相同或相近的感觉去激活要困难的多。<br>不论可能的进化原因是什么，我们的大脑没有进化回忆事实的能力。古希腊的演讲者采用“轨迹法”来记住长篇大论中的要点。他们想象有一座庞大的建筑或者广场，想象在那里的不同地方放置他们演讲的要点。在演讲时，他们在心中依次“走”过这些地方，“捡起”被放在那个位置的要点。<br>对设计的影响：</p>
<ul>
<li>看到和选择比回忆和输入更容易</li>
<li>尽可能使用图像来表达功能</li>
<li>使用缩略图来紧凑地描绘全尺寸的图像<br>识别对象和事件时所使用的尺寸并不敏感，重要的是特征，只要大部分同样的特征在新的图像和原始图像中都出现了，新的感知就会触发同样的神经活动模式，从而产生识别。</li>
<li>使用视觉提示让用户知道他们所处的位置<br>视觉识别是快速且可靠的，因此设计者们可以使用视觉提示来实时地告知用户他们当前所处的位置。</li>
</ul>
<h3 id="第十章_从经验中学习与学后付诸实践很容易，解决问题和计算很难">第十章 从经验中学习与学后付诸实践很容易，解决问题和计算很难</h3>
<p>人们善于从具体的经验和观察中概括并得出结论，快速和容易的从经验中学习的能力具有进化上的优势。<br>然而，我们从经验中学习的能力并不完美，原因：</p>
<ul>
<li>第一，对复杂的情况，比如那些涉及了很多可变因素或者受许多难以预料的外界因素影响的情况，人们很难做出预测。</li>
<li>第二，从自己生活中或者亲人好友那里获得的经验要比那些读到的或者听到的经验对我们更有影响力。这么做是因为我们的大脑认为家庭成员与自己更相似，也就比其他成千上百不知名的消费者更可信。虽然从理性的角度看，统计数据要可靠的多。</li>
<li>第三，当人们犯了错后，并不总能学到正确的教训。当发现自己处于一个糟糕的环境时，他们并不能很好地记起最近的行为从而将自己当前的处境与真正的原因联系起来。</li>
<li>第四，人们经常过度概括，片面总结。然而<strong>过度概括其实是对现实世界的必要的适应，我们让自己因过度概括而陷入麻烦的首要原因是用极端的方式进行过度概括，例如基于一个例子或非典型例子就做出概括。</strong></li>
</ul>
<p>从经验中学习有可能是无意识的，当人们熟练掌握某种方法或行为，他们就可以达到一种“无意识”的状态；<br>然而，解决问题和计算则必须依赖有意识的进行推理，要求不间断的主动意识或专注的注意力。</p>
<p>交互系统应该尽可能减少用户不得不投入注意力去操作它们，这会把稀缺的认知资源从他们要解决的任务上抽离出来。因此，设计应遵循：</p>
<ul>
<li>显著标识系统状态和用户当前进度</li>
<li>引导用户完成他们的目标</li>
<li>不要让用户诊断系统问题</li>
<li>尽可能减小设置的数量和复杂度</li>
<li>让用户使用感觉而不是计算   一些看起来可能要求计算的问题可以用图形化的方式展示出来，允许人们通过快速的感觉而不是计算来实现自己的目标</li>
<li>让系统令人感觉到熟悉   使用用户已经了解的概念、词汇和图像来尽可能让用户对系统感到熟悉，尽少地想到系统本身。</li>
<li>让电脑去计算</li>
</ul>
<h3 id="第十一章_许多因素影响学习">第十一章 许多因素影响学习</h3>
<p>我们第一次进行某个操作时，采用的是高度受控和有意识的方式，但随着练习，它就变得越来越无意识。削苹果皮、开车、阅读、演奏乐器都是这样的例子。我们该如何设计，才能使得对软件系统的操作能够在一个合理的时间范围内成为无意识的？</p>
<p><strong>第一，当操作专注于任务、简单和一致时，我们学得更快</strong><br>  认知心理学家把用户想要完成的任务和工具所能提供的操作之间的差距称为“执行的鸿沟”。使用工具的人必须耗用认知力量将他想要做的转换成该工具所能提供的操作。这种认知努力将人的注意力从任务上拽走，放到了对工具的要求上。缩小这个鸿沟的办法是把工具设计得使其提供的操作能够匹配用户所要做的事情。做到以下三步：<br>  1.做一个任务分析<br>    任务分析应该弄清这些问题：<br>    用户在使用这个应用时想要实现什么目的？<br>    应用想支持哪些人群的任务？<br>    哪些任务是常见的，哪些是少见的？哪些是最重要的，哪些是不重要的？<br>    每个任务的步骤是什么？结果和输出是什么？每个任务所需的信息从哪来？每个任务的信息该怎么利用？<br>    什么人做什么任务？每个任务该使用哪些工具？执行各个任务时，人们会遇到什么问题？什么样的错误是常见的？是什么造成这些错误？错误造成的损害会有多严重？<br>    人们在执行这些任务时都使用什么样的词汇？<br>    要执行这些任务，人们必须如何沟通？<br>    不同的任务之间是如何联系的？<br>  2.设计一个专注于任务的概念模型，其中主要包括对象-操作分析<br>    <strong>概念模型</strong>解释一款软件的功能以及要使用它用户需要了解哪些概念。工具的概念和其支持的任务所需概念之间的映射越直接，用户就越少做它们之间的转换，也就越容易学习使用。<br>    概念模型一定要专注于用户任务，与任务无关的对象和操作不需要用户知道。<br>    <strong>尽可能简单</strong>：只要能让用户达到目标完成任务，少即是多。例如对于一个To-Do列表应用来说，用户是否需要给某项任务指定1~10个优先级别，还是只要准备两个优先级（高、低）就够了呢？很多开发过程都会有一种添加额外功能的压力，以防<strong>“用户万一需要这个功能”，在面临这种压力时，除非确有迹象表明会有很多潜在客户或者用户需要它，否则一定要</strong>坚决抵制<strong>。</strong>每多考虑一种可能性，就会让软件变得更复杂一些。<strong>况且每一个新想法都要与很多其他的想法发生联系，导致复杂性进一步上升。新想法的加入导致应用程序复杂性的增加不是线性的，而是</strong>倍增关系<strong>。
    </strong>一致性<strong>：一个交互系统的用户从受控的、有意识监控的、缓慢的操作，进步到无意识的、无需监控的和更快的操作，这个过程的速度受到系统一致性的严重影响。</strong>系统不同功能的操作越可预期，它的一致性就越高。过度复杂源于不同又太相似的概念**。一些应用软件由于用了许多含义或功能上相互重叠的功能而变得非常复杂。例如：会员，订阅，访问权限，权利资格。<br>    一致性包括两个层面：概念层面和按键层面。<br>    可以用一个由对象和操作组成的矩阵来展示概念模型：暂且忽略对象类型的层级结构，先把它们一一列出。对象越多，矩阵越高，操作越多，矩阵越宽。小且紧凑的矩阵对应的设计是容易学习的。<br>    按键层面的一致能够很快让用户进入“肌肉记忆”的操作习惯中。开发者促进按键层面上的一致性的一个常见办法是遵循用户界面标准。应在概念和任务层面上创新而在按键层面上坚持惯例。<br>  3.严格按照任务分析和概念模型设计用户界面</p>
<p><strong>第二，当词汇专注于任务、熟悉和一致时，我们学得更快</strong><br>  开发团队应从概念模型中创造一个产品词典。在这个词典里，用户能接触到的每个对象、动作和属性都有一个名字和定义。词条和概念在词典中一一对应，不该出现多个词汇对应到一个概念或者一个词汇对应多个概念的情况。词典中的词条应从软件所支持的任务中产生，而不是来自具体的实现方式。<br>  应把产品词典视为一个活文档：随着产品的发展演进，词典应在新的设计心得、功能的变化、可用性测试的结果和市场反馈的基础上做出相应的变化。</p>
<p><strong>第三，风险低的时候我们学得更快</strong><br>  在低风险的系统里，用户不容易犯错误，犯错的代价很低，也很容易修正，那就能减少用户的压力并鼓励探索，因此也就大大促进了学习。因此设计中应注意：尽可能防止出错；停用不合理的命令；向用户清晰展示他们做了什么，这样错误就容易被发现；让用户能轻松撤销、反转或者修正错误。</p>
<h3 id="第十二章_我们有时间要求">第十二章 我们有时间要求</h3>
<p><strong>交互系统的响应度是决定用户满意度的最重要因素，没有“之一”。</strong><br>响应度，与性能相关，但又不一样。性能是以单位时间里的计算次数来衡量的，响应度是以服从用户在时间上的要求及用户满意度来衡量的。【用户取得的成就越多，就会认为系统的速度越快，尽管他们的评价往往与系统的实际速度有很大出入。】<br>高响应度的交互系统并不一定是高性能的。高响应度的系统即使无法立刻完成用户请求，也能让用户了解状况。它们对用户的操作和执行情况提供反馈，并且根据人类感觉、运动和认知的时长来安排反馈的优先顺序。具体来说，它们做到：</p>
<ul>
<li>立刻告知已经接收到你的输入；</li>
<li>对操作需要多长时间完成提供一定的指示；</li>
<li>在等待时允许你去做其他事情；</li>
<li>能够智能管理事件队列；</li>
<li>将系统内部管理和低优先级的任务放在后台运行；</li>
<li>对最常见的用户请求作出预期。<br>即使运行速度非常快，软件也可能有非常糟糕的响应度，因为它无法与用户保持一致，不能对用户操作做出即时的反馈。</li>
</ul>
<p><strong>人类大脑的一些时间常量</strong></p>
<ol>
<li>声音中我们所能察觉到的最短的沉默间隙：1ms（0.001s）<br>耳朵的传导是机械的，比视网膜的视锥细胞和视杆细胞对光的反应更快。听觉系统察觉出声音到达两耳的微小的时间差，大脑通过这个差异计算出声源的方向。</li>
<li>可见且能对我们产生影响（或许是无意识的）的视觉刺激的最短时长：5ms<br>这就是所谓潜意识知觉的基础。5~10ms向你展现一幅图，在你识别出之前就消失了，那么其效果就是你对它的熟悉度增加了。当然，潜意识知觉不是行为的决定因素，不能让你做你不想做的事，也不能让你想要你本不想要的东西。</li>
<li>挠反射的速度（对危险的非自主的运动反应）：80ms<br>车祸中的人通常他们的胳膊和手上的伤口证明他们能够在瞬间抬手保护自己。挠反射要比对于一个感知到的事件有意识的反应要快得多：快了近10倍。</li>
<li>一个视觉事件与我们完整感知之间的时间差：100ms</li>
<li>人们谈话中的最长沉默间隔：1s</li>
</ol>
<p><strong>满足实时交互的设计</strong><br>原则：</p>
<ul>
<li>立刻告知收到用户的动作，即使回应用户需要时间。保持用户对因果关系的感知。</li>
<li>让用户知道软件是否在忙</li>
<li>在等待一个功能完成的同时允许用户做别的事情</li>
<li>动画要做到平滑和清晰</li>
<li>让用户能够终止（取消）他们不想要的长时间的操作</li>
<li>让用户知道长时间的操作需要多长时间</li>
<li>尽可能让用户来掌控自己的工作节奏<br>0.1s：如果软件对用户的动作显示反馈超过了0.1s，因果关系的感知就被打破了。软件的反馈也就不会被视为对用户动作的反应。<br>1s：1s是对话中可以有的最长沉默间隔，交互系统作为一个对话形式，应该避免出现超过1s的无反应时间。<br>  1s也是对一个未预料的事件做有准备的反应的最小时间。因此，当信息突然出现在屏幕上时，设计者可以假设用户需要1s做出反应，这个时延在系统需要显示一个交互对象但无法在0.1s内完成渲染和交互准备时就有用了。实际上，系统可以显示一个“伪造的”、不可交互的版本，然后再花时间（1s）去填补细节和让对象完成可交互的准备。<br>10s：差不多是用户愿意花费在重量级操作上的时间，例如文件交换和搜索。如果更长，用户就开始失去信心。如果系统提供了进度反馈，操作的时间可以更长些。</li>
</ul>
<p><strong>高响应度交互系统的另外一些指导原则：</strong></p>
<ul>
<li>使用忙碌标识</li>
<li>使用用户进度指示</li>
<li>单位任务内的延迟比单位任务之间的延迟更令人厌烦（因为单位任务内是工作记忆和感知区域必须保持相对稳定的时间段。如果系统有延迟，放在单位任务之间而不是之内）</li>
<li>先显示全局/重要信息，再补充细节和辅助信息。不要等到所有显示内容完全渲染之后才让用户看到。<br>例如，文档编辑软件在打开文档时，在第一时间打开第一页，而不会等到加载完整个文档后才打开；搜索引擎在搜索时会尽早在找到结果后就立即显示出来，同时再搜索更多匹配内容。高分辨率的图片渲染起来比较慢，系统可以迅速渲染出低分辨率的图像，然后再重新渲染出高分辨率的图像。人的视觉系统对图像具有<strong>整体感知</strong>的特点，这样就比慢吞吞的从上至下显示高分辨率图像给人的感觉更快。但不推荐对<strong>文本</strong>先显示低分辨率版本，再显示高分辨率版本。<br>这样做的好处是：让用户相信计算机很快就能给出答案；相对于进度指示器，用户更喜欢看到逐步深入的结果。</li>
<li>提前处理</li>
<li>临时降低工作质量保证快速响应<br>例如交互动画为了保证平滑，会简化渲染工作，牺牲文字标记、三维效果和高光与阴影等细节。宁可临时降低动画的三维效果也不能将帧速率降到限度之下。</li>
</ul>
<p>——————总结——————<br>交互设计是一门技艺，不仅要学习设计准则，还要学习在不同的设计环境中如何判断使用哪条规则。<br>理解了设计准则背后的认知心理学背景知识，这些准则看起来就不再像某个用户界面设计大师随意制定的规则了，背景知识也能够帮助我们在实际环境中解释、权衡和应用设计准则。</p>

      
    </div>
    <footer>
      
        
        
  
  <div class="tags">
    <a href="/tags/读书笔记/">读书笔记</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:cynthia-yang.github.io">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Open-Course/">Open Course</a><small>1</small></li>
  
    <li><a href="/tags/产品思考/">产品思考</a><small>3</small></li>
  
    <li><a href="/tags/产品设计/">产品设计</a><small>3</small></li>
  
    <li><a href="/tags/市场调研/">市场调研</a><small>4</small></li>
  
    <li><a href="/tags/文摘/">文摘</a><small>2</small></li>
  
    <li><a href="/tags/社会与时事/">社会与时事</a><small>2</small></li>
  
    <li><a href="/tags/科普/">科普</a><small>1</small></li>
  
    <li><a href="/tags/统计学/">统计学</a><small>1</small></li>
  
    <li><a href="/tags/行业观察/">行业观察</a><small>3</small></li>
  
    <li><a href="/tags/读书笔记/">读书笔记</a><small>2</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2015 Cynthia Yang
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'blogofcynthia';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>